---
layout: post
title: 事务
categories: [java,SQL,事务]
description: 事务
keywords: java,SQL,事务
---

## 事务

事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。

## 一:事务简介

核心: 锁  并发
优势:容易理解
劣势:性能较低

容易理解的模型性能都不好,
性能好的模式都不容易理解
这就是生活

DRDS已经正式登陆阿里云

## 事务单元

一个事务单元: bob给smith 100块
加锁让事务读写操作顺序执行,保证数据一致性

ACID保证事务完整性 : A原子性,C一致性,I 隔离性,D持久性

以下都是事务
建立索引
读取一行记录
写入一行记录,同事更新记录的所有所有
删除整张表
所有对数据的每个操作
Etc...

一组事务单元: 
bob给smith 100块,
smith给joe 100块,
smith给bob 100块

事务单元之间的happen-before关系
读写 写读 读读 写写
任何事务单元之间都是上面四种关系
书籍 <<事务处理>>

问题 如何能够以最块的速度完成?
又能保证上面的四种操作的逻辑顺序

## 二:处理事务的常见思路

事务-排队法
序列化读写  多个事务单元顺序执行读写
优势---不需要冲突控制
劣势---慢速设备...

事务-排他锁 
针对同一个事务单元的访问进行控制
没有共享数据的事务单元就是独立的事务单元,可以和其它独立单元加锁并行

事务-读写锁
读读 并行  其它三种顺序

事务-MVCC 主流 多版本事务控制
本质就是copy on write
能够做到写不阻塞读


来自百度百科
ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。

排他锁，又称为写锁、独占锁，是一种基本的锁类型。

## 三:事务处理常见问题
事务处理-先后顺序
一个读请求应该读哪一个写之后的数据?
逻辑时间戳 : 保证事务单元先后
scn(oracle)
trx_id(Innodb)
Etc...

事务处理-故障恢复
可能的错误情况,业务属性不匹配,保证原子性,回滚
系统崩溃: 事务单元中间状态突然崩溃后重启要回滚,不能被其他应用使用,所以数据库有一个恢复状态

事务处理-死锁与死锁检测
死锁产生的原因: 
两个线程
不同方向
相同资源

死锁的解决方案
尽可能不死锁
碰撞检测  --- 主流数据库使用
等锁超时  -- 辅助事务

从单机事务到分布式事务
分布式事务与单机事务,相同与不同
分布式事务的主要难题
传统数据库的分布式事务
新兴互联网行业的分布式事务尝试
  Google Spanner赏析
  阿里的分布式事务模型
  DRDS/TDDL实践

事务的ACID
一致性 can(happen before)
隔离性 以性能为理由,对一致性的破坏
读写锁 
读已提交 read committed
  读读并行, 读写并行(写读还不能)
读未提交 
  只加写锁,读不加锁

隔离性小结
SQL92标准定义的隔离性
序列化 
可重复读
读已提交
读未提交   

新的 快照隔离级别
Multi-Version Concurrency Control 多版本并发控制，MVCC 
新的方式 MVCC 多版本控制 读读并行,读写并行,写读并行

加锁后的读未提交可能读到中间状态的数据,业务不允许
但是使用快照读的情况下能保证在一致性的同时实现读未提交

SQL92标准 滞后于 人的实现
标准 不等于  对  ACID不一定对

业务应用的发展已经远远超过对传统意义上事务的认识

写 和  写   有没有可能并行?

快照(snapshot isolation)
 - 针对读多写少场景优化
 - 并行度能到达或超过度位提交,而隔离级别很高

持久性 
事务完成以后,该事务对数据库所作的更改便持久的保存在数据库中
BUT  如何才能确保数据不丢呢?

RAID 的持久性
1.磁盘的物理损坏
2.每一次commit都要fsync到磁盘,性能下降
持久性和延迟 两个对立

1.提交请求到内存后返回,一批提交在刷到磁盘,做到块存储
2.将内存的数据打包到磁盘

## 核心目的: 提示并行度

单机事务的典型异常应对策略
业务属性不匹配
 - 原子性
 - 一致性 
 - 回滚

## 系统DOWN级
重启后进入recovery模式
 提交后事务单元继续完成提交
 为提交事务单元回滚
recovery 进程挂掉,重启recovery
记录日志,保证不会出现数据丢失....

## 事务的调优原则
事务的调优的思路是在不影响业务应用的前提下：
第一，尽可能减少锁的覆盖范围，例如Myisam表锁到Innodb的行锁就是一个减少锁覆盖范围的过程；对于原位锁（排他锁、读写锁等）可变为MVCC多版本（本质仍然是减少锁的范围）。
第二，增加锁上可并行的线程数，例如读锁和写锁的分离，允许并行读取数据。
第三，选择正确锁类型，其中悲观锁适合并发争抢比较严重的场景；乐观锁适合并发争抢不太严重的场景。
 
悲观锁: 使得线程到blocking状态,通知信息OK的状态切换回等待状态, 寄存器CPU上下文换入换出, 又可能性能降低,
乐观锁: 

## 单机事务拾遗
1.事务单元扩展

2.死锁扩展 - U锁

3.MVCC拾遗
 

分布式事务面临的问题

google spanner的创新与代价

DRDS/TDDL的实践


## 参考

慕课网沈询事务视频
https://www.imooc.com/video/9493
沈询阿里博客
http://jm.taobao.org/2017/02/09/20170209/